Part A

1. Checked that 3000physicalview is loaded using `lsmod | grep 3000physicalview` command

2.The put_user and get_user macros allow you to access that memory. Put_user and get_user can not access several characters at once whereas, you can handle several characters at once with copy_to_user and copy_from_user. It would cause error if we dont.

3. The  ioctl(), the abbreivation of input/output control, is a system call that can be used for special devices when read and write doesn't work. 

ioctl in 3000physicalview is implemented using the file descriptor, the int to receive commands, and the address parameter. It returns -EINVAL when cmd is not PHYSICALVIEW_WALK and it has various conditional statment when it is PHYSIALVIEW_WALK.

ioctl in 3000memview2 is called in the report_memory function. It passes fd file descriptor, and option for PHSYICALVIEW_WALK is enabled, and the address for the memory is passed.  

Part B

1. The following is the memory report output:
Memory map report (virtual -> physical)
argv:       0x00007ffddd652878 -> 0x000000003615d878
argv[0]:    0x00007ffddd654780 -> 0x000000003774d780
envp:       0x00007ffddd652888 -> 0x000000003615d888
envp[0]:    0x00007ffddd65478f -> 0x000000003774d78f
lmsg:       0x000055eafac4104e -> 0x000000001bdeb04e
&lmsg:      0x00007ffddd652648 -> 0x000000003615d648
gmsg:       0x000055eafac410f8 -> 0x000000001bdeb0f8
&gmsg:      0x000055eafac43010 -> 0x00000000237eb010
main:       0x000055eafac40140 -> 0x000000005d189140
&buf:       0x00007ffddd652650 -> 0x000000003615d650
buf[00]:    0x000055eafbe3d6b0 -> 0x00000000164396b0
buf[01]:    0x000055eafbe3e6c0 -> 0x0000000063cfc6c0
buf[02]:    0x000055eafbe3f6d0 -> 0x00000000344da6d0
buf[03]:    0x000055eafbe406e0 -> 0x000000001a2c06e0
buf[04]:    0x000055eafbe416f0 -> 0x0000000038e7d6f0
buf[05]:    0x000055eafbe42700 -> 0x000000006a15f700
buf[06]:    0x000055eafbe43710 -> 0x0000000026020710
buf[07]:    0x000055eafbe44720 -> 0x00000000165cf720
buf[08]:    0x000055eafbe45730 -> 0x00000000021e4730
buf[09]:    0x000055eafbe46740 -> 0x000000007fe95740
buf[10]:    0x000055eafbe47750 -> 0x0000000023cb6750
buf[11]:    0x000055eafbe48760 -> 0x0000000038c23760
buf[12]:    0x000055eafbe49770 -> 0x000000005d0f1770
buf[13]:    0x000055eafbe4a780 -> 0x0000000068cf6780
buf[14]:    0x000055eafbe4b790 -> 0x00000000140eb790
buf[15]:    0x000055eafbe4c7a0 -> 0x000000004a6b77a0
buf[16]:    0x000055eafbe4d7b0 -> 0x00000000238d47b0
buf[17]:    0x000055eafbe4e7c0 -> 0x000000005d4607c0
buf[18]:    0x000055eafbe4f7d0 -> 0x00000000501ee7d0
buf[19]:    0x000055eafbe507e0 -> 0x00000000664677e0
buf[20]:    0x000055eafbe517f0 -> 0x0000000069dd67f0
buf[21]:    0x000055eafbe52800 -> 0x0000000002122800
buf[22]:    0x000055eafbe53810 -> 0x00000000553e2810
buf[23]:    0x000055eafbe54820 -> 0x000000002eed4820
buf[24]:    0x000055eafbe55830 -> 0x00000000109ca830
buf[25]:    0x000055eafbe56840 -> 0x0000000038c21840
buf[26]:    0x000055eafbe57850 -> 0x000000003369f850
buf[27]:    0x000055eafbe58860 -> 0x000000006c099860
buf[28]:    0x000055eafbe59870 -> 0x0000000051ec0870
buf[29]:    0x000055eafbe5a880 -> 0x000000001d1b4880

The virtual memory address seems to be ordered and is sensical, but the physical memory seems to be placed in random locations (except the last 3 digits).

2.
3000memview2.c has report_memory function where they use ioctl system call while 3000memview.c does not. The difference in their ways of reading the memory seemingly have caused a slight difference in their memory address. One other thing to be noticed is that the memory address in 3000memview.c is similar to the virtual memory map in 3000memview2.c.

3.

As seen in #1 above, there is a pattern one can notice in buf[i] increases by 16+16^3 when incrementally increased respectively. 


4.
Whenever we re-run 3000memview2, the virtual memory address incrementally increase linearly. 

The argv address increases by 1E16CC000 everytime, the buffer address increases by 774C7FB000 everytime we re-run, and so on. 

The physical address however, seems to be completely random, except lsmg, gmsg, and main has a constant physical address that doesn't change over re-runs. This is probably because the global/local strings are already allocated and would we a waste of memory if reallocated. Same thing goes with function address. The reasons possibly have to do something with how it is stored in heap and stack. 

5.
Probably it has something to do with erasing all the stored values that were obtained in previous run, by erasing all caches.








